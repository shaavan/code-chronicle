# Log 181: _A Victory!_

> 26 June 2025

## What I Worked On:

- [Solved](https://github.com/shaavan/rust-lightning/commits/currency-13) the
  compile-time check model for the `InvoiceRequest` event model

## Reflections:

Picking up from yesterdayâ€™s work, I came at the problem today with fresh eyes â€”
and something clicked.

To reiterate the challenge:  
How do we introduce **compile-time functional guarantees** for both
`amount_source` and `signing_key_strategy` â€” without falling into the trap of
**combinatorial explosion** in enum variants and function definitions?

It took a while to get the structure mapped clearly in my mind. But once I saw
it on paper â€” layered, clean, and sequenced â€” the rest fell into place.

Hereâ€™s the approach I took:  
What if, at each step in preparing an `InvoiceRequest` for generating an
`InvoiceBuilder`, we **resolve one axis of variation at a time** â€” never
combining them all at once?

In practice, this translated into a layered design:

1. Start with a basic `InvoiceRequest`.
2. After verification, produce a `VerifiedInvoiceRequestEnum`, capturing the key
   context via `SigningKeyStrategy` and `AmountSourceEnum`.
3. Pass this through an **amount resolution layer** to compute a usable
   `amount_msats`, resulting in a `VerifiedInvoiceRequestEnumWithAmountToUse`.
4. Finally, use this cleanly resolved structure to build the `InvoiceBuilder`,
   with logic scoped only to the signing key strategy.

Because each concern is handled in its own layer, we never have to manage all
combinations at once â€” **no explosion, no duplication**, just clean flow.

What a feeling when a hard problem opens up after youâ€™ve poured your heart into
it.  
A real victory â€” not just in code, but in design clarity. ðŸš€
