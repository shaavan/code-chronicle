# Log 320: Eureka

> 05 Feb 2026

## What I Worked On

- [Figured out] the currency conversion implementation approach

## Reflections

Today was a real breakthrough.

[After aligning] on supporting currency conversion through a synchronous method and
trait parameterization, I set out to implement the direction we had discussed. But
since we had already decided to restart from first principles, I paused and asked
a harder question:

If we’re rebuilding this, why preserve an architectural choice that no longer
feels right?

The earlier approach threaded the conversion trait through multiple layers of
Bolt12 communication — invoice request creation, invoice generation,
verification, and payment. It worked. But it felt invasive. Currency awareness
was leaking into too many places, and I could sense the long-term cost of that
design.

The turning point was realizing something simple:

At every stage of Bolt12 communication, we only need to resolve the Offer’s
amount.

That’s it.

So instead of propagating conversion logic throughout the system, we can resolve
the Offer amount at the source, remember the resolved value, and let the rest of
the codebase operate purely in msats.

That shift changes the shape of the solution. Currency handling becomes
localized. The trait plumbing disappears from the broader flow. The architecture
stays clean, instead of gradually bending around a special case.

Once that clicked, the path forward became obvious. Implementation is halfway
there. If the prototype holds up, the next step is polish and push.

A good day — the kind where the design feels lighter by the end of it.

[Figured out]: https://github.com/shaavan/rust-lightning/commits/currency-39
[After aligning]:
  https://github.com/lightningdevkit/rust-lightning/pull/3833#issuecomment-3755856013
