# Weekly Log 32: _Reevaluation, Execution, and Emergence_

> 31 July 2025 – 05 August 2025

## What I Worked On:

- [Restructured and expanded](https://github.com/shaavan/rust-lightning/commits/currency-25)
  the **Event-Model**, rethinking design assumptions from the ground up
- [Completed and cleaned up](https://github.com/shaavan/rust-lightning/commits/currency-26)
  the **Synchronous Currency** branch
- [Opened PR #3833](https://github.com/lightningdevkit/rust-lightning/pull/3833)
  introducing the synchronous currency interface
- Tamed the CI — fixing edge-case errors and iterating through local test
  failures to get the PR green
- Began studying the
  [Recurrence Spec PR](https://github.com/lightning/bolts/pull/1240), taking
  notes and formulating questions
- [Refined documentation and naming](https://github.com/lightningdevkit/rust-lightning/pull/3964)
  for the `VerifiedInvoiceRequest` PR based on reviewer suggestions
- Discussed approaches and open questions with mentor

## Reflections:

This week felt like a turning point — a moment of pulling back, reevaluating the
map, and then charging forward with renewed precision.

After weeks of layering changes on top of each other, I realized some decisions
in the event-model had grown too brittle. So I paused. I questioned each choice
— from how we use the `CurrencyConversion` trait to how flows are constructed.
That reset gave rise to a much cleaner architecture and surfaced a key insight:
before anything else, we needed a more appropriate constructor for
`ChannelManager`.

In parallel, I focused fully on synchronous currency support — separating it
from the event-model to give it the clarity it deserved. Uploading it came with
its own challenges: CI snags, tiny import errors, long debug cycles. But the
rigor paid off. By the end, the branch wasn’t just complete — it was clean,
understandable, and something I felt proud to open as a PR.

As those threads settled, I turned toward the future — diving into the
recurrence spec. It reminded me how elegant and complex protocol design can be,
and how important it is to ask the right questions early.

Through it all, I was guided by reflection, iteration, and mentorship — and came
out with stronger ideas, cleaner code, and a deeper sense of where I'm heading
next.
