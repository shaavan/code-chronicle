# Log 226: On Statelessness

> 06 Sept 2025

## What I Worked On

- Mapped out next implementation steps for [recurrence].

## Reflections

Today was more of a “pen over code” day—focused on design thinking rather than
implementation. The challenge: how to achieve near-statelessness for the
recurrence model.

For the uninitiated, statelessness refers to a system’s ability to function
without needing to remember internal state. The current spec structure—invoice
containing invoice request containing offer—already enables a surprisingly
efficient, nearly stateless design in LDK. Most things can be reconstructed on
demand.

I wanted to bring that same elegance to recurrence.

After breaking things down, I realized LDK only truly needs to retain a few
pieces of information:

- The payer ID for the invoice request (to link the chain of payments)
- The index of the last successful payment
- The time period of the first invoice

That’s it. Or... so it seemed.

Then came a twist: what if someone sends _identical_ invoice requests again? LDK
would recreate the invoice from scratch, potentially shifting the time anchor.
This could break expectations—mismatching payment windows, altering amounts
(especially under fluctuating exchange rates), and undermining the deterministic
intent of the flow.

So: the “stateless ideal” might need a touch of state after all.  
The journey to recurrence statelessness continues—and I’m curious where the
constraints will lead us.

[recurrence]: https://github.com/shaavan/rust-lightning/commits/recurrence-03
